\documentclass[a4paper,twoside,twocolumn]{article}

\usepackage{times}
\usepackage{color}
\usepackage{graphicx}
\usepackage{alltt}
\usepackage{textcomp}
\usepackage{drawstack}
\usepackage{float}

\usepackage{a4med}
\usepackage{comp-tut}

\renewcommand{\textfraction}{0.0}
\renewcommand{\floatpagefraction}{1.0}
\renewcommand{\dblfloatpagefraction}{1.0}
\renewcommand{\topfraction}{1.0}
\renewcommand{\dbltopfraction}{1.0}
\setcounter{topnumber}{3}
\setcounter{dbltopnumber}{3}
\setcounter{totalnumber}{3}

\newcommand{\figurerule}{\rule{\textwidth}{0.5pt}}
\newcommand{\OPN}[1]{\textbf{#1}}
%\newcommand{\OP}[2]{\item[#1]}
\newcommand{\OP}[2]{\item[#1]}% (#2)}

\newcommand{\nb}[1]{}
%\renewcommand{\nb}[1]{{\color{blue}#1}}
\newcommand{\LT}{$<$}

\begin{document}

\thispagestyle{empty}
\title{\vspace*{-3cm}Interpreter}
\author{Brae Webb}
\maketitle
\pagestyle{myheadings}
\markboth{PL0 Interpreter (\today)}{Brae Webb (\today)}
\vspace*{-4ex}

An interpreter is a type of program, similar to a compiler, which builds an
abstract syntax tree from input source code. An interpreter differs from a
compiler in that it does not generate machine code. Instead it will evaluate
the expression nodes and execute the statement nodes in an abstract syntax tree
directly in order to run the input program.


The PL0 Abstract Syntax Tree (AST) is comprised of expression nodes
(\texttt{ExpNode}) and statement nodes (\texttt{StatementNode}). The PL0
Interpreter uses a visitor pattern to visit each of the statement and expression
nodes.

\section{Evaluating Expression Nodes}\label{section:expressions}
When an expression node is visited it is evaluated into an \texttt{Integer}.
Expression nodes consist of atomic and composite nodes. Atomic nodes retrieve
their values from variable lookup or user input, examples are the 
\texttt{VariableNode} and \texttt{ReadNode}. Composite nodes are derived from
other composite nodes or atomic nodes, examples are the \texttt{OperatorNode}
and \texttt{DereferenceNode}.

%An expression node is visited by calling the 
%\emph{.evaluate(ExpTransform$\langle$Integer$\rangle$)} method of the node.

\begin{figure}[H]
\begin{java}
public Integer visitReadNode(ExpNode
        .ReadNode node) {
    beginExec("Read");
    /* Read next int from input stream */
    int result;
    try {
        result = Integer
                .parseInt(in.readLine());
    } catch (Exception e) {
        runtime("read value not int",
                node.getLocation(),
                currentFrame);
        return -1; // Never reached
    }
    endExec("Read");
    return result;
}
\end{java}
\caption{Evaluating a \texttt{ReadNode}}\label{figure:readnode}
\end{figure}

\section{Executing Statement Nodes}\label{section:statements}
When a statement node is visited it executes Java code that simulates the
behaviour of the node it represents in PL0. For example, a \texttt{WriteNode}
will evaluate its \texttt{ExpNode} and print the result to the output.

\begin{figure}[H]
\begin{java}
public void visitWriteNode(StatementNode
        .WriteNode node) {
    beginExec("Write");
    /* Evaluate the code in the
     * write expression */
    int result = node.getExp()
            .evaluate(this);
    /* Print the result to the 
     * output stream */
    outStream.println(result);
    endExec("Write");
}
\end{java}
\caption{Executing a \texttt{WriteNode}}\label{figure:writenode}
\end{figure}

\section{Interpreter Frames}\label{section:frame}

If recursion was not allowed in the language,
each procedure could maintain its set of variables.
However PL0, like all modern languages, supports recursion
and hence there can be multiple activations of the same procedure
each with its own instance of the procedure's variables.
To support multiple activations of procedures in PL0 
one can use a stack of \emph{frames}.
Each time a procedure is called 
(including the initial call of the main program)
a new (stack) frame for that procedure is pushed onto the stack.
In the compiler a (stack) frame of an activation of a procedure \textsf{p} 
is represented by an object that contains 
\begin{itemize}
\item
a link to \textsf{p}'s parent's frame 
(called a \emph{dynamic link} or \emph{control link})
\item
a static link (described below)
and 
\item
an array containing the values of the variables for tthis activation of \textsf{p}.
\end{itemize}

In PL0 procedures may be nested inside other procedures to an arbitrary depth.
An inner procedure can access its own local variables
as well as the variables of all the procedures in which it is nested 
(including the main program).
To implement this in the interpreter, the activation frame of a procedure \textsf{q}
is linked to the frame of the most recent activation of the procedure (or main program)
in which it is directly included, say \textsf{p}, and then the activation frame 
for \textsf{p} is linked to the most recent activation of the procedure in 
which it is directly included, and so on, all the way up to the main program
at the outermost level. 

In PL0 there is only one frame instance for the main program:
the very first frame created when the program starts execution.

Fig. \ref{figure:exampleprog} is an example PL0 program, it has no functional
purpose, it is used to demonstrate how frames are implemented within the PL0
interpreter. It defines a procedure p which calls itself and then calls the
procedure q.

\begin{figure}[H]
\rule{\columnwidth}{0.5pt}
\begin{alltt}\sf
var x: int;
    y: int;
procedure p() =
  var y: int;
  procedure q() =
    begin
      x := x
    end;
  begin
    if x = 0 then
      x = 1;
      y := 10;
      call p()
    else
      y := 20;
      call q()
    end
  end;
begin // main program
  x := 0;
  y := 50;
  call p()
end
\end{alltt}
\rule{\columnwidth}{0.5pt}
\caption{Example Program}\label{figure:exampleprog}
\end{figure}

During semantic analysis of the program, procedure and variable static levels
and variable offsets are determined.
This information is used by the interpreter to store and load variables within
the correct scope.

Each call to a procedure creates a new \texttt{Frame} which stores the procedures
local variables in an array of \texttt{Integer}s. A \texttt{Frame} also stores
a static link and a dynamic link.

\begin{description}
\item[a static link] (also called an \emph{access link}) links to the closest
frame which is one static level above the current frame. The static link
is used to resolve non-local variables.

\item[a dynamic link] (also called a \emph{control link}) links to the frame
of the calling procedure. The dynamic link is used to return to the previous
frame when a procedure returns.
\end{description}

\subsection{Frame Lookup}\label{section:lookup}
The static levels of procedures and variables as determined by the semantic
analysis are used to lookup frames. A frame is looked up by a static level,
the static links are followed until a frame with a matching static level is
found.

\subsection{Calling a Procedure}\label{section:call}
When a procedure is called a new frame is entered. The static level of the
procedure being called is used to lookup the frame which will be used for the
static link. The current frame is used as the dynamic link of the new frame.

\subsection{Assigning Variables}\label{section:assignment}
When assigning a variable the static level of the variable is used to lookup
the frame to store the variable within. The offset of the variable is used
to assign a value in the frames array of \texttt{Integer}s.

\subsection{Looking Up Variables}\label{section:lookup}
When looking up a variable the static level of the variable is used to lookup
the frame where the variable should be stored. The offset of the variable is
used to index the array of \texttt{Integer}s stored in the frame.

\tikzstyle{staticLink}=[fill=blue!10!orange!10,draw=blue!30!black]
\tikzstyle{dynamicLink}=[fill=yellow!20,draw=blue!30!black]

\begin{figure}[H]
\begin{tikzpicture}
  \drawstruct{(0,8)}
  \llstructcell{0.5}{freecell}{~} \coordinate (mainHead) at (currentcell.east);
  \structcell[staticLink]{staticLink}
  \structcell[dynamicLink]{dynamicLink}
  \structcell[freecell]{level = 0}
  \structcell[freecell]{procedure = \texttt{<main>}}
  \structcell[freecell]{entries = [0, 50]}
  \structname{
    \begin{tabular}{c}
      \texttt{<main>}
    \end{tabular}
  }

  \drawstruct{(0,0)}
  \llstructcell{0.5}{freecell}{~} \coordinate (p2Head) at (currentcell.west);
  \structcell[staticLink]{staticLink} \coordinate (p2sl) at (currentcell.west);
  \structcell[dynamicLink]{dynamicLink} \coordinate (p2dl) at (currentcell.east);
  \structcell[freecell]{level = 1}
  \structcell[freecell]{procedure = \texttt{p}}
  \structcell[freecell]{entries = [20]}
  \structname{
    \begin{tabular}{c}
      \texttt{p}
    \end{tabular}
  }

  \drawstruct{(4,8)}
  \llstructcell{0.5}{freecell}{~} \coordinate (p1Head) at (currentcell.west);
  \structcell[staticLink]{staticLink} \coordinate (p1sl) at (currentcell.west);
  \structcell[dynamicLink]{dynamicLink}  \coordinate (p1dl) at (currentcell.west);
  \structcell[freecell]{level = 1}
  \structcell[freecell]{procedure = \texttt{p}}
  \structcell[freecell]{entries = [10]}
  \structname{
    \begin{tabular}{c}
      \texttt{p}
    \end{tabular}
  }

  \drawstruct{(4,0)}
  \llstructcell{0.5}{freecell}{~} \coordinate (qHead);
  \structcell[staticLink]{staticLink} \coordinate (qsl) at (currentcell.west);
  \structcell[dynamicLink]{dynamicLink} \coordinate (qdl) at (currentcell.west);
  \structcell[freecell]{level = 2}
  \structcell[freecell]{procedure = \texttt{q}}
  \structcell[freecell]{entries = []}
  \structname{
    \begin{tabular}{c}
      \texttt{q}
    \end{tabular}
  }

  \draw[->] (p1sl) to [out=150,in=30] (mainHead);
  \draw[->] (p1dl) to [out=150,in=30] (mainHead);
  \draw[->] (p2sl) to [out=150] (mainHead);
  \draw[->] (p2dl) to [out=70] (p1Head);
  \draw[->] (qsl) to [out=150,in=30] (p2Head);
  \draw[->] (qdl) to [out=150,in=30] (p2Head);
\end{tikzpicture}
\caption{Frames of Example Program}\label{figure:frames}
\end{figure}

Fig. \ref{figure:frames} is a visual representation of the instances of
\texttt{Frame} that are created when the example program in Fig.
\ref{figure:exampleprog} is interpreted.

\end{document}