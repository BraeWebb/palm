\documentclass[a4paper,twoside,twocolumn]{article}

\usepackage{times}
\usepackage{color}
\usepackage{graphicx}
\usepackage{alltt}
\usepackage{textcomp}
\usepackage{drawstack}
\usepackage{float}

\usepackage{a4med}
\usepackage{comp-tut}

\renewcommand{\textfraction}{0.0}
\renewcommand{\floatpagefraction}{1.0}
\renewcommand{\dblfloatpagefraction}{1.0}
\renewcommand{\topfraction}{1.0}
\renewcommand{\dbltopfraction}{1.0}
\setcounter{topnumber}{3}
\setcounter{dbltopnumber}{3}
\setcounter{totalnumber}{3}

\newcommand{\figurerule}{\rule{\textwidth}{0.5pt}}
\newcommand{\OPN}[1]{\textbf{#1}}
%\newcommand{\OP}[2]{\item[#1]}
\newcommand{\OP}[2]{\item[#1]}% (#2)}

\newcommand{\nb}[1]{}
%\renewcommand{\nb}[1]{{\color{blue}#1}}
\newcommand{\LT}{$<$}

\begin{document}

\thispagestyle{empty}
\title{\vspace*{-3cm}Interpreter}
\author{Brae Webb}
\maketitle
\pagestyle{myheadings}
\markboth{PL0 Interpreter (\today)}{Brae Webb (\today)}
\vspace*{-4ex}

An interpreter is a type of program, similar to a compiler, which builds an
abstract syntax tree from input source code. An interpreter differs from a
compiler in that it does not generate machine code. Instead it will evaluate
the expression nodes and execute the statement nodes in an abstract syntax tree
directly in order to run a program.


The PL0 Abstract Syntax Tree (AST) is comprised of expression nodes
(\texttt{ExpNode}) and statement nodes (\texttt{StatementNode}). The PL0
Interpreter uses a visitor pattern to visit each of the statement and expression
nodes.

\section{Evaluating Expression Nodes}\label{section:expressions}
When an expression node is visited it is evaluated into an \texttt{Integer}.
Expression nodes consist of atomic and composite nodes. Atomic nodes retrieve
their values from variable lookup or user input, examples are the 
\texttt{VariableNode} and \texttt{ReadNode}. Composite nodes are derived from
other composite nodes or atomic nodes, examples are the \texttt{OperatorNode}
and \texttt{DereferenceNode}.

%An expression node is visited by calling the 
%\emph{.evaluate(ExpTransform$\langle$Integer$\rangle$)} method of the node.

\begin{figure}[H]
\begin{java}
public Integer visitReadNode(ExpNode
        .ReadNode node) {
    beginExec("Read");
    /* Read next int from input stream */
    int result;
    try {
        result = Integer
                .parseInt(in.readLine());
    } catch (Exception e) {
        runtime("read value not int",
                node.getLocation(),
                currentFrame);
        return -1; // Never reached
    }
    endExec("Read");
    return result;
}
\end{java}
\caption{Evaluating a \texttt{ReadNode}}\label{figure:readnode}
\end{figure}

\section{Executing Statement Nodes}\label{section:statements}
When a statement node is visited it executes Java code that simulates the
behaviour of the node it represents in PL0. For example, a \texttt{WriteNode}
will evaluate its \texttt{ExpNode} and print the result to the output.

\begin{figure}[H]
\begin{java}
public void visitWriteNode(StatementNode
        .WriteNode node) {
    beginExec("Write");
    /* Evaluate the code in the
     * write expression */
    int result = node.getExp()
            .evaluate(this);
    /* Print the result to the 
     * output stream */
    outStream.println(result);
    endExec("Write");
}
\end{java}
\caption{Executing a \texttt{WriteNode}}\label{figure:writenode}
\end{figure}

\section{Interpreter Frame}\label{section:frame}

Fig. \ref{figure:exampleprog} is an example PL0 program, it has no functional
purpose, it is used to demonstrate how frames are implemented within the PL0
interpreter. It defines a procedure p which calls itself then calls the
procedure q.

\begin{figure}[H]
\rule{\columnwidth}{0.5pt}
\begin{alltt}
var x: int;
    y: int;
procedure p() =
  var y: int;
  procedure q() =
    begin
      x := x
    end;
  begin
    if x = 0 then
      x = 1;
      y := 10;
      call p()
    else
      y := 20;
      call q()
    end
  end;
begin // main program
  x := 0;
  y := 50;
  call p()
end
\end{alltt}
\rule{\columnwidth}{0.5pt}
\caption{Example Program}\label{figure:exampleprog}
\end{figure}

During semantic analysis of the program procedure and variable static levels
and variable offsets are determined.
This information is used by the interpreter to store and load variables within
the correct scope.


\tikzstyle{staticLink}=[fill=blue!10!orange!10,draw=blue!30!black]
\tikzstyle{dynamicLink}=[fill=yellow!20,draw=blue!30!black]

\begin{figure}[H]
\begin{tikzpicture}
  \drawstruct{(0,8)}
  \llstructcell{0.5}{freecell}{~} \coordinate (mainHead) at (currentcell.east);
  \structcell[staticLink]{staticLink}
  \structcell[dynamicLink]{dynamicLink}
  \structcell[freecell]{staticLevel = 0}
  \structcell[freecell]{proc = \texttt{<main>}}
  \structcell[freecell]{x = 0}
  \structcell[freecell]{y = 50}
  \structname{
    \begin{tabular}{c}
      \texttt{<main>}
    \end{tabular}
  }

  \drawstruct{(0,0)}
  \llstructcell{0.5}{freecell}{~} \coordinate (p2Head) at (currentcell.west);
  \structcell[staticLink]{staticLink} \coordinate (p2sl) at (currentcell.west);
  \structcell[dynamicLink]{dynamicLink} \coordinate (p2dl) at (currentcell.east);
  \structcell[freecell]{staticLevel = 1}
  \structcell[freecell]{proc = \texttt{p}}
  \structcell[freecell]{y = 20}
  \structname{
    \begin{tabular}{c}
      \texttt{p}
    \end{tabular}
  }

  \drawstruct{(4,8)}
  \llstructcell{0.5}{freecell}{~} \coordinate (p1Head) at (currentcell.west);
  \structcell[staticLink]{staticLink} \coordinate (p1sl) at (currentcell.west);
  \structcell[dynamicLink]{dynamicLink}  \coordinate (p1dl) at (currentcell.west);
  \structcell[freecell]{staticLevel = 1}
  \structcell[freecell]{proc = \texttt{p}}
  \structcell[freecell]{y = 10}
  \structname{
    \begin{tabular}{c}
      \texttt{p}
    \end{tabular}
  }

  \drawstruct{(4,0)}
  \llstructcell{0.5}{freecell}{~} \coordinate (qHead);
  \structcell[staticLink]{staticLink} \coordinate (qsl) at (currentcell.west);
  \structcell[dynamicLink]{dynamicLink} \coordinate (qdl) at (currentcell.west);
  \structcell[freecell]{staticLevel = 2}
  \structcell[freecell]{proc = \texttt{q}}
  \structname{
    \begin{tabular}{c}
      \texttt{q}
    \end{tabular}
  }

  \draw[->] (p1sl) to [out=150,in=30] (mainHead);
  \draw[->] (p1dl) to [out=150,in=30] (mainHead);
  \draw[->] (p2sl) to [out=150] (mainHead);
  \draw[->] (p2dl) to [out=70] (p1Head);
  \draw[->] (qsl) to [out=150,in=30] (p2Head);
  \draw[->] (qdl) to [out=150,in=30] (p2Head);
\end{tikzpicture}
\caption{Frames of Example Program}\label{figure:frames}
\end{figure}

\end{document}